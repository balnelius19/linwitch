<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Mini Doom-like JS</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#0f0;font:14px monospace;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}
  #hud{position:fixed;left:10px;top:10px;pointer-events:none;white-space:nowrap;text-shadow:0 0 6px #0f0}
  #msg{position:fixed;right:10px;top:10px;text-align:right;pointer-events:none;text-shadow:0 0 6px #0f0}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"></div>
<div id="msg"></div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');

  // Resize
  function resize() {
    canvas.width = Math.max(480, Math.floor(window.innerWidth));
    canvas.height = Math.max(270, Math.floor(window.innerHeight));
  }
  window.addEventListener('resize', resize);
  resize();

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    if (e.key === ' ') e.preventDefault();
    keys[e.key] = true;
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // RNG helper
  const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
  const choice = arr => arr[(Math.random()*arr.length)|0];

  // Game state
  let map, mapW, mapH;
  let level = 1;
  const maxLevel = 10;
  let score = 0;
  let ammo = 5;
  let reloading = false;
  let reloadTimer = 0;
  let spaceLatch = false;
  let player = { x:1.5, y:1.5, a:0 };
  let enemies = [];
  let bullets = []; // enemy bullets
  const playerRadius = 0.2;
  const moveSpeed = 3.0; // units/s
  const rotSpeed = 2.4;  // rad/s
  const fov = Math.PI/3; // 60°
  const maxViewDist = 20;
  let zbuf = new Float32Array(canvas.width);

  // Maze generation (recursive backtracker on odd grid)
  function genMaze(w=21,h=21){
    if (w%2===0) w++; if (h%2===0) h++;
    const grid = Array.from({length:h},()=>Array(w).fill(1));
    function neighbors(cx,cy){
      const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
      return dirs.map(([dx,dy])=>[cx+dx,cy+dy,dx,dy]).filter(([nx,ny])=>nx>0&&ny>0&&nx<w-1&&ny<h-1&&grid[ny][nx]===1);
    }
    function carve(x=1,y=1){
      grid[y][x]=0;
      const nbs = neighbors(x,y).sort(()=>Math.random()-0.5);
      for (const [nx,ny,dx,dy] of nbs){
        if (grid[ny][nx]===1){
          grid[y+dy/2][x+dx/2]=0;
          carve(nx,ny);
        }
      }
    }
    carve(1,1);
    // Add a few random openings
    for (let i=0;i<Math.floor(w*h*0.01);i++){
      grid[(Math.random()*(h-2)+1)|0][(Math.random()*(w-2)+1)|0]=0;
    }
    return {grid,w,h};
  }

  function cell(x,y){ return map[y|0]?.[x|0] ?? 1; }
  function isWall(x,y){ return cell(x,y)===1; }

  // Raycast using DDA; returns {dist, hitX, hitY, side}
  function castRay(rx, ry, ra){
    let mapX = rx|0, mapY = ry|0;
    const rayDirX = Math.cos(ra), rayDirY = Math.sin(ra);
    const deltaDistX = Math.abs(1 / (rayDirX||1e-9));
    const deltaDistY = Math.abs(1 / (rayDirY||1e-9));
    let stepX, stepY, sideDistX, sideDistY, side=0;

    if (rayDirX < 0){ stepX = -1; sideDistX = (rx - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - rx) * deltaDistX; }
    if (rayDirY < 0){ stepY = -1; sideDistY = (ry - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - ry) * deltaDistY; }

    while (true){
      if (sideDistX < sideDistY){ sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
      if (mapY<0||mapX<0||mapY>=mapH||mapX>=mapW) break;
      if (map[mapY][mapX] === 1) break;
    }
    const perpWallDist = side===0 ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
    const hitX = rx + rayDirX * perpWallDist;
    const hitY = ry + rayDirY * perpWallDist;
    return { dist: perpWallDist, hitX, hitY, side };
  }

  // LOS check between (x1,y1) and (x2,y2)
  function hasLineOfSight(x1,y1,x2,y2){
    const ang = Math.atan2(y2-y1, x2-x1);
    const step = 0.05;
    const maxd = Math.hypot(x2-x1,y2-y1) - 0.1;
    for (let d=0; d<maxd; d+=step){
      const xx = x1 + Math.cos(ang)*d;
      const yy = y1 + Math.sin(ang)*d;
      if (isWall(xx,yy)) return false;
    }
    return true;
  }

  function spawnEnemies(){
    enemies = [];
    const count = level*2;
    let tries = 0;
    while (enemies.length < count && tries < 2000){
      tries++;
      const x = ((Math.random()*(mapW-2)+1)|0) + 0.5;
      const y = ((Math.random()*(mapH-2)+1)|0) + 0.5;
      if (!isWall(x,y) && Math.hypot(x-player.x,y-player.y) > 4){
        enemies.push({ x, y, alive:true, tShoot: 0, wander: rand(0,1) });
      }
    }
  }

  function newLevel(){
    const {grid,w,h} = genMaze(23 + (level%2), 23 + (level%2));
    map = grid; mapW = w; mapH = h;
    // Place player near start
    player.x = 1.5; player.y = 1.5; player.a = 0;
    // Make sure start is open
    map[1][1] = 0; map[1][2]=0; map[2][1]=0;
    spawnEnemies();
    bullets = [];
    ammo = 5; reloading = false; reloadTimer = 0; spaceLatch = false;
    msg.textContent = `Niveau ${level}`;
    setTimeout(()=>{ if (msg.textContent.startsWith('Niveau')) msg.textContent=''; }, 800);
  }

  function saveScore(){
    try{
      const key='lastScores';
      const arr = JSON.parse(sessionStorage.getItem(key)||'[]');
      arr.push(score);
      const last3 = arr.slice(-3);
      sessionStorage.setItem(key, JSON.stringify(last3));
    }catch(err){}
  }
  function getLastScores(){
    try{
      return JSON.parse(sessionStorage.getItem('lastScores')||'[]');
    }catch(_){ return []; }
  }

  function enemyFireInterval(){
    // Linear from 1.1s (lvl1) to 0.1s (lvl10)
    const t = (level-1)/9;
    return 1.1 - t*1.0; // seconds
  }

  function update(dt){
    // Input
    if (keys['ArrowLeft']) player.a -= rotSpeed*dt;
    if (keys['ArrowRight']) player.a += rotSpeed*dt;

    const fwd = (keys['ArrowUp']?1:0) - (keys['ArrowDown']?1:0);
    const spd = moveSpeed*dt;
    const nx = player.x + Math.cos(player.a)*spd*fwd;
    const ny = player.y + Math.sin(player.a)*spd*fwd;
    // collision
    if (!isWall(nx, player.y)) player.x = nx;
    if (!isWall(player.x, ny)) player.y = ny;

    // Shooting (Space once per press)
    if (keys[' '] && !spaceLatch && !reloading && ammo>0){
      spaceLatch = true;
      shoot();
    }
    if (!keys[' ']) spaceLatch = false;

    // Reload
    if (reloading){
      reloadTimer -= dt;
      if (reloadTimer <= 0){
        reloading = false;
        ammo = 5;
      }
    }

    // Enemies wander and shoot
    const iv = enemyFireInterval();
    for (const e of enemies){
      if (!e.alive) continue;
      // Simple wandering: small random drift, avoid walls
      if (Math.random()<0.02) e.wander = rand(0, Math.PI*2);
      const ex = e.x + Math.cos(e.wander)*dt*1.2;
      const ey = e.y + Math.sin(e.wander)*dt*1.2;
      if (!isWall(ex, e.y)) e.x = ex;
      if (!isWall(e.x, ey)) e.y = ey;

      // Shooting
      e.tShoot -= dt;
      if (e.tShoot <= 0){
        if (hasLineOfSight(e.x,e.y,player.x,player.y)){
          const ang = Math.atan2(player.y-e.y, player.x-e.x);
          const speed = 7.0; // bullet speed (units/s)
          bullets.push({ x:e.x, y:e.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:3 });
        }
        e.tShoot = iv;
      }
    }

    // Bullets update
    for (const b of bullets){
      if (b.dead) continue;
      const steps = 3; // substeps for collision
      for (let i=0;i<steps;i++){
        b.x += b.vx*dt/steps;
        b.y += b.vy*dt/steps;
        b.life -= dt/steps;
        if (isWall(b.x,b.y) || b.life<=0){ b.dead=true; break; }
        if (Math.hypot(b.x-player.x,b.y-player.y) < playerRadius){
          score = Math.max(-999999, score-1);
          b.dead = true;
          // brief flash
          flashTimer = 0.05;
          break;
        }
      }
    }
    bullets = bullets.filter(b=>!b.dead);

    // Level progression
    if (enemies.every(e=>!e.alive)){
      if (level < maxLevel){
        level++;
        newLevel();
      } else {
        // Game over (win)
        saveScore();
        const last3 = getLastScores();
        msg.innerHTML = `Terminé ! Score: ${score}\nDerniers scores: ${last3.join(', ')}\nEspace: rejouer`;
        gameOver = true;
      }
    }
  }

  function shoot(){
    ammo--;
    // Hitscan ray forward
    const step = 0.03;
    let hitEnemy = null, hitDist = Infinity;
    for (let d=0; d<maxViewDist; d+=step){
      const xx = player.x + Math.cos(player.a)*d;
      const yy = player.y + Math.sin(player.a)*d;
      if (isWall(xx,yy)) break;
      for (const e of enemies){
        if (!e.alive) continue;
        if (Math.hypot(e.x-xx, e.y-yy) < 0.35){
          hitEnemy = e; hitDist = d; break;
        }
      }
      if (hitEnemy) break;
    }
    if (hitEnemy){
      hitEnemy.alive = false;
      score += 100;
      // Little message
      msg.textContent = '+100';
      setTimeout(()=>{ if (msg.textContent==='+100') msg.textContent=''; }, 300);
    }
    // Auto-reload after 5 shots
    if (ammo <= 0){
      reloading = true;
      reloadTimer = 2.0;
    }
  }

  // Rendering
  let flashTimer = 0;
  function draw(){
    const w = canvas.width, h = canvas.height;
    // Sky/Floor
    ctx.fillStyle = '#202020';
    ctx.fillRect(0,0,w,h/2);
    ctx.fillStyle = '#050505';
    ctx.fillRect(0,h/2,w,h/2);

    // Walls via raycasting
    zbuf = new Float32Array(w);
    for (let x=0; x<w; x++){
      const camX = (2*x/w)-1;
      const rayAng = player.a + Math.atan(camX * Math.tan(fov/2));
      const res = castRay(player.x, player.y, rayAng);
      let dist = Math.min(res.dist, maxViewDist);
      zbuf[x] = dist;
      const lineH = Math.max(1, (h / (dist+0.0001)) * 0.9);
      const y0 = ((h - lineH) / 2)|0;

      // Shading
      const shade = Math.max(0, 1 - dist/maxViewDist);
      const base = res.side ? 180 : 220;
      const v = Math.max(0, Math.min(255, (base*shade)|0));
      ctx.fillStyle = `rgb(${v},${v},${v})`;
      ctx.fillRect(x, y0, 1, lineH);
    }

    // Sprites (enemies)
    const sprites = [];
    for (const e of enemies){
      if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.hypot(dx,dy);
      const ang = Math.atan2(dy,dx) - player.a;
      let a = ((ang + Math.PI)%(2*Math.PI)) - Math.PI;
      if (Math.abs(a) > fov/1.2) continue; // culled
      const size = Math.min(h, (h / dist));
      const sx = (w/2) + (a/(fov/2)) * (w/2);
      sprites.push({sx, size, dist, color:'#b00'});
    }
    // Sprites (bullets)
    for (const b of bullets){
      const dx = b.x - player.x, dy = b.y - player.y;
      const dist = Math.hypot(dx,dy);
      const ang = Math.atan2(dy,dx) - player.a;
      let a = ((ang + Math.PI)%(2*Math.PI)) - Math.PI;
      if (Math.abs(a) > fov/1.2) continue;
      const size = Math.min(h, (h / dist) * 0.3);
      const sx = (canvas.width/2) + (a/(fov/2)) * (canvas.width/2);
      sprites.push({sx, size, dist, color:'#fff'});
    }

    // Draw sprites with simple z-buffer test
    sprites.sort((a,b)=>b.dist-a.dist);
    for (const s of sprites){
      const x0 = (s.sx - s.size/2)|0, y0 = ((canvas.height - s.size)/2)|0;
      ctx.fillStyle = s.color;
      const wRect = Math.max(1, s.size|0);
      for (let x=0; x<wRect; x++){
        const sx = x0 + x;
        if (sx<0||sx>=canvas.width) continue;
        if (s.dist < zbuf[sx] + 0.01){
          ctx.fillRect(sx, y0, 1, s.size|0);
        }
      }
    }

    // Gun / reticle
    ctx.fillStyle = '#0f0';
    const cx = w>>1, cy = h>>1;
    ctx.fillRect(cx-8, cy, 16, 1);
    ctx.fillRect(cx, cy-8, 1, 16);

    // Damage flash
    if (flashTimer > 0){
      ctx.fillStyle = 'rgba(255,0,0,0.2)';
      ctx.fillRect(0,0,w,h);
      flashTimer -= 1/60;
    }

    // HUD
    const last3 = getLastScores();
    hud.innerHTML =
      `Niveau: ${level}/${maxLevel}<br>` +
      `Score: ${score}<br>` +
      `Munitions: ${reloading ? 'Recharge...' : `${ammo}/5`}<br>` +
      `Cadence ennemie: ${enemyFireInterval().toFixed(1)} s<br>` +
      `Derniers scores: ${last3.join(', ')||'—'}`;
  }

  // Game loop
  let last = performance.now()/1000;
  let gameOver = false;
  function loop(t){
    const now = t/1000;
    const dt = Math.min(0.05, now-last);
    last = now;
    if (!gameOver){
      update(dt);
      draw();
    }else{
      // Wait for space to restart
      if (keys[' '] && !spaceLatch){
        spaceLatch = true;
        // Reset game
        level = 1; score = 0; gameOver=false; msg.textContent='';
        newLevel();
      }
      if (!keys[' ']) spaceLatch = false;
    }
    requestAnimationFrame(loop);
  }

  // Init
  newLevel();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>